#!/usr/bin/env ruby
# frozen_string_literal: true

require 'pathname'
require 'yaml'
require 'json'
require 'shellwords'
require 'bundler/setup'
require 'pp'
require 'logger'
require 'pry'

LoadYaml = YAML.method(:safe_load)
Esc = Shellwords.method(:shellescape)
Puts = method(:puts)
PathnameNew = Pathname.method(:new)
Pp = method(:pp)

Cwd = Pathname.new(Dir.pwd)
Script = Cwd / Pathname.new(__FILE__)
Root = Cwd / Script.dirname

ScrollName = Cwd.basename.to_s.freeze
ArtifactLib = (Root / '_artifacts').relative_path_from(Cwd)
ARTIFACT_DIR = (ArtifactLib / ScrollName)
PackerYamlPath = Pathname.new('packer.yaml')
PackerJsonPath = Pathname.new('_packer.json')

@logger = Logger.new(STDERR).tap { |l| l.progname = 'Build' }

def inspex(cmd)
  @logger.info "Bye bye! I'm off to be #{cmd.join ' '} now!"
  exec(*cmd)
end

def load_yaml(path)
  @logger.info "Parsing #{path} as YAML"
  path&.open('r', &LoadYaml)&.freeze
end

def dump_json(path, data)
  @logger.info "Dumping #{data.inspect[0..20]}... to #{path}"

  return @logger.info 'bailing' unless data && path

  path.open('w') do |fout|
    fout.write JSON.pretty_generate data
  end
end

def packer_pure
  @packer_pure ||= load_yaml PackerYamlPath
end

#
# Injecting packer builders with stuffz.
#
module InjectPackerBuilder
  Vagrant = lambda { |builder|
    builder.dup.tap do |b2|
      b2['output_dir'] = ARTIFACT_DIR.to_s.freeze
      # b2['skip_add'] = true
    end
  }

  DISPATCH_TABLE = {
    'vagrant' => Vagrant
  }.freeze

  Dispatch = lambda { |builder|
    DISPATCH_TABLE[builder['type']]
      .tap do |cb|
        raise "No builder injection found for #{builder['type']}" unless cb
      end
      .call(builder)
  }

  module_function

  def to_proc
    Dispatch
  end
end

VARIABLES = {
  'artifact_lib' => ArtifactLib.to_s
}.freeze

def packer
  p = packer_pure
  @packer ||= p
              .merge(
                'builders' => (p['builders'] || []).map(&InjectPackerBuilder),
                'variables' => (p['variables'] || {}).merge(VARIABLES)
              )
              .freeze
end

def dump_packer_json
  dump_json PackerJsonPath, packer
end

def packer!
  @logger.info 'I\'m gonna become packer now! Bahbah!'
  inspex %W[
    /usr/bin/env packer build #{PackerJsonPath}
  ]
end

def gen
  dump_packer_json
end

def build!
  gen
  packer!
end

def blast
  `vagrant box list --machine-readable`
    .each_line
    .map { |l| l.chomp.split(',')[2..3] }
    .select { |type,| type == 'box-name' }
    .map { |_, name| "vagrant box remove #{Esc.call name}" }
    .each(&Puts)
end

#
# Bullshit related to Vagrant specific builders
#
module Vagrant
  IS_VAGRANT = lambda { |builder|
    builder['type'] == 'vagrant'
  }

  def builder
    @builder ||= packer['builders']&.find(&IS_VAGRANT)
  end

  def source_box
    @source_box ||= builder['source_path']
  end

  def source_box_exists?
    @logger.info "Acquiring source box info... #{source_box}"
    `vagrant box list --machine-readable`
      .each_line
      .map { |l| l.chomp.split(',')[2..3] }
      .select { |type,| type == 'box-name' }
      .map { |_, name| name }
      .find { |n| n == source_box }
  end

  def add_box_if_missing
    if source_box_exists?
      @logger.info "Found #{source_box}. Skipping add."
    else
      @logger.info 'Didn\'t find shit. Gonna be vagrant now, c you!'
      inspex %W[
        /usr/bin/env vagrant box add #{source_box}
      ]
    end
  end
end

case $PROGRAM_NAME
when __FILE__
  case ARGV[0]
  when 'gen' then gen
  when 'BLAST' then blast
  when 'add_box_if_missing' then add_box_if_missing
  when 'j2y'
    puts YAML.dump JSON.load STDIN
  when 'y2j'
    puts JSON.pretty_generate YAML.load STDIN
  else build!
  end
end
