#!/usr/bin/env ruby
# frozen_string_literal: true
require 'pathname'
require 'yaml'
require 'json'
require 'shellwords'
require 'bundler/setup'
require 'pp'
require 'logger'

LoadYaml = YAML.method(:safe_load)
Esc = Shellwords.method(:shellescape)
Puts = method(:puts)
PathnameNew = Pathname.method(:new)
Pp = method(:pp)

Cwd = Pathname.new(Dir.pwd)
Script = Cwd / Pathname.new(__FILE__)
Root = Cwd / Script.dirname

ScrollName = Cwd.basename.to_s.freeze
ArtifactDir = (Root / '_artifacts' / ScrollName).relative_path_from(Cwd)
PackerYamlPath = Pathname.new('packer.yaml')
PackerJsonPath = Pathname.new('_packer.json')

@logger = Logger.new(STDERR).tap { |l| l.progname = 'Build' }

def load_yaml(path)
  @logger.info "Parsing #{path} as YAML"
  path&.open('r', &LoadYaml)&.freeze
end

def dump_json(path, data)
  @logger.info "Dumping #{data.inspect[0..20]}... to #{path}"

  return @logger.info 'bailing' unless data && path

  path.open('w') do |fout|
    fout.write JSON.pretty_generate data
  end
end

def packer_pure
  @packer_pure ||= load_yaml PackerYamlPath
end

def packer
  @packer ||= packer_pure.dup.tap do |p|
    (p['variables'] ||= {}).tap do |vars|
      vars['artifact_dir'] = ArtifactDir.to_s.freeze
        .tap { |d| @logger.info "Injecting artifact_dir: #{d}" }
      vars['artifact_name'] = ScrollName
        .tap { |n| @logger.info "Injecting artifact_name: #{n}" }
    end
      .freeze
  end
    .freeze
end

def source_yaml_path
  @soure_yaml_path ||= Dir['*_source.yaml']
    .map(&PathnameNew)
    .first
end

def source_json_path
  @source_json_path ||= (
    yaml = source_yaml_path || return
    stem = yaml.basename('.yaml').to_s
    dir = yaml.dirname
    json_name = "_#{stem.to_s}.json"
    yaml.dirname / json_name
  )
end

def source
  @source ||= load_yaml source_yaml_path
end

def dump_packer_json
  dump_json PackerJsonPath, packer
end

def dump_source_json
  dump_json source_json_path, source
end

def packer!
  @logger.info 'I\'m gonna become packer now! Bahbah!'
  exec *%W[
    /usr/bin/env packer build #{PackerJsonPath}
  ]
end

def gen
  dump_packer_json
  dump_source_json
end

def build!
  gen
  packer!
end

def blast
  `vagrant box list --machine-readable`
    .each_line
    .map { |l| l.chomp.split(',')[2..3] }
    .select { |type,| type == 'box-name' }
    .map { |_, mn| "vagrant box remove #{Esc.call mn}" }
    .each(&Puts)
end

case ARGV[0]
when 'gen' then gen
when 'BLAST' then blast
else build! if __FILE__ == $0
end
